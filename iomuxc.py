#!/usr/bin/env python3

"""
This script generates the imxrt-iomuxc pad API from an i.MX RT SVD
file. Consider using the patched SVD files provided by the imxrt-ral
project.

Usage:

    python3 iomuxc.py path/to/imxrt.svd | rustfmt > path/to/output.rs
"""

import re
import sys
import xml.etree.ElementTree as ET
from collections import defaultdict

NEW_DOCSTRING = """
/// Take all pads from this group
///
/// # Safety
///
/// You may safely call this once to acquire all of the pads.
/// Subsequent calls may return pads that are mutably aliased
/// elsewhere. Consider calling new() at the start of your program."""

ERASE_DOCSTRING = """
/// Erase all of the pads
///
/// The return type is an array, where the index indicates the
/// pad offset from the start of the group. For example, AD_B0_03
/// would be referenced as erased_pads\[3\].
///
/// See `ErasedPads` for more information."""

def iomuxc(path):
    tree = ET.parse(path)
    root = tree.getroot()
    iomuxc = root.find("./peripherals/peripheral[name='IOMUXC']")
    base_address = int(iomuxc.find("./baseAddress").text, 16)

    # Collect MUX and PAD absolute register addresses.
    pads = defaultdict(dict)
    for register in iomuxc.findall("./registers/register"):
        name = register.find("./name").text
        if "SW_MUX_CTL_PAD_" in name:
            name = name.replace("SW_MUX_CTL_PAD_", "")
            offset = int(register.find("./addressOffset").text, 16)
            pads[name]["MUX"] = base_address + offset

            # Figure out the associated GPIO from the ALTs.
            mux_field = register.find("./fields/field[name='MUX_MODE']")
            if mux_field is None:
                continue

            for alt in mux_field.findall("./enumeratedValues/enumeratedValue"):
                desc = alt.find("./description").text

                # This is the path taken on nearly all i.MX RT variants...
                if gpio_match := re.search("GPIO\d_IO\d{2}", desc):
                    gpio_text = gpio_match.group(0)
                    [gpio_module, gpio_offset] = re.findall("\d+", gpio_text)
                    gpio_module = int(gpio_module)
                    gpio_offset = int(gpio_offset)
                # ...except for the 1010, which references "GPIO1_IOxx"
                # as "GPIOMUX_IOxx".
                elif gpio_match := re.search("GPIOMUX_IO\d{2}", desc):
                    gpio_text = gpio_match.group(0)
                    [gpio_offset] = re.findall("\d+", gpio_text)
                    gpio_module = 1
                    gpio_offset = int(gpio_offset)
                else:
                    # There's no (expected) GPIO alt. This path is handled
                    # later during code generation.
                    continue
                pads[name]["GPIO_ALT"] = alt_value = int(alt.find("./value").text, 16)
                pads[name]["GPIO_MODULE"] = gpio_module
                pads[name]["GPIO_OFFSET"] = gpio_offset

        elif "SW_PAD_CTL_PAD_" in name:
            name = name.replace("SW_PAD_CTL_PAD_", "")
            offset = int(register.find("./addressOffset").text, 16)
            pads[name]["PAD"] = base_address + offset

    # Sanity check.
    for name, registers in pads.items():
        assert("PAD" in registers and "MUX" in registers)

    # Create pad groups.
    groups = defaultdict(list)
    for name in pads.keys():
        group = name[:-len("_01")]
        groups[group].append(name)

    # Generate Rust modules
    print("// Generated by iomuxc.py")
    print("#![allow(non_camel_case_types)]")
    print()
    for group, pad_names in groups.items():
        print(f"/// Pads with the prefix {group}.")
        print(f"pub mod {group.lower()} {{")
        print()

        # Pad type aliases, constants.
        for pad_name in pad_names:
            registers = pads[pad_name]

            mux_addr = hex(registers["MUX"])
            pad_addr = hex(registers["PAD"])

            mux_reg_name = f"{pad_name}_MUX_ADDR"
            pad_reg_name = f"{pad_name}_PAD_ADDR"
            print(f"const {mux_reg_name}: u32 = {mux_addr};")
            print(f"const {pad_reg_name}: u32 = {pad_addr};")
            print(f"pub type {pad_name} = crate::Pad<{mux_reg_name}, {pad_reg_name}>;")

            # impl gpio::Pin
            if "GPIO_ALT" in registers:
                print()
                print(f"impl crate::gpio::Pin for {pad_name} {{")
                print(f"const ALT: u32 = {registers['GPIO_ALT']};")
                print(f"type Module = crate::consts::U{registers['GPIO_MODULE']};")
                print(f"type Offset = crate::consts::U{registers['GPIO_OFFSET']};")
                print("}")
            else:
                print(f"// {pad_name} does not have a GPIO alternate.")
            print()

        # Pads struct
        print(f"/// All pads with prefix {group}.")
        print("pub struct Pads {")
        for pad_name in pad_names:
            pad_number = pad_name[-len("01"):]
            print(f"pub p{pad_number}: {pad_name},")
        print("}")

        # ErasedPads
        print(f"/// Erased pads with prefix {group}.")
        print("///")
        print("/// Use [`Pads::erase()`] to get an `ErasedPads` instance.")
        print(f"pub type ErasedPads = [crate::ErasedPad; {len(pad_names)}];")

        # Pads impl
        print("impl Pads {")

        print(NEW_DOCSTRING)
        print("#[inline] pub const unsafe fn new() -> Self { Self {")
        for pad_name in pad_names:
            pad_number = pad_name[-len("01"):]
            print(f"p{pad_number}: {pad_name}::new(),")
        print("} }")

        print(ERASE_DOCSTRING)
        print("#[inline] pub const fn erase(self) -> ErasedPads { [")
        for pad_name in sorted(pad_names):
            pad_number = pad_name[-len("01"):]
            print(f"self.p{pad_number}.erase(),")
        print("] }")
        print("}")

        print("}")
        print()

    # Generate top-level Pads struct
    print("/// All of the pads.")
    print("pub struct Pads {")
    for group in groups.keys():
        print(f"pub {group.lower()}: {group.lower()}::Pads,")
    print("}")

    print("impl Pads {")
    print(NEW_DOCSTRING)
    print("#[inline] pub const unsafe fn new() -> Self { Self {")
    for group in groups.keys():
        print(f"{group.lower()}: {group.lower()}::Pads::new(),")
    print("} }")
    print(ERASE_DOCSTRING)
    print("#[inline] pub const fn erase(self) -> ErasedPads { ErasedPads {")
    for group in groups.keys():
        print(f"{group.lower()}: self.{group.lower()}.erase(),")
    print("} }")
    print("}")

    # Generate top-level ErasedPads struct
    print("/// All erased pads.")
    print("pub struct ErasedPads {")
    for group in groups.keys():
        print(f"pub {group.lower()}: {group.lower()}::ErasedPads,")
    print("}")

if __name__ == "__main__":
    iomuxc(sys.argv[1])
